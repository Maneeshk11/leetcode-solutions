# Reverse Integer

-----

#### Description: 

Given a signed 32-bit integer ```x```, return ```x``` with its digits reversed. If reversing ```x``` causes the value to go outside the signed 32-bit integer range $$ [-2^{31}$$, 2^{31} - 1] $$, then return ```0```.

**Assume the environment does not allow you to store 64-bit integers (signed or unsigned).**

#### Examples:

```txt
Input: x = 123
Output: 321
```

```txt
Input: x = -123
Output: -321
```

```txt
Input: x = 120
Output: 21
```

#### Constraints: 

 - ``` -2^{31} <= x <= 2^{31} - 1```

#### Code: 

```cpp
class Solution {
public:
    int reverse(int x) {
        int flag = 1;
        if (x < 0) {
            flag = -1;
        }
        int number = 0;
        x = abs(x);
        while (x > 0) {
            number = (number*10) + x%10;
            x = x/10;
            if (number > INT_MAX/10 && x != 0) {
                return 0;
            }
        }
        return flag * number;
    }
};
```

#### Explanation:

- We first declare a flag variable to store the sign of the number.
- We then initialize a variable ```number``` to store the reversed number.
- We take the absolute value of the input number to handle negative numbers.
- We iterate over the input number and keep updating the ```number``` variable by multiplying it by 10 and adding the last digit of the input number.
- We also check if the ```number``` variable is going out of the ```32-bit integer``` range by comparing it with ```INT_MAX / 10```. We do this so we don't end up with an number greater than ```INT_MAX``` when we multiply the ```number``` variable by 10.
- Finally, we return the reversed number with the correct sign. (by multiplying it with the flag)

#### Complexity Analysis:

- **Time Complexity:** ```O(log(x))```, where ```x``` is the input number.
