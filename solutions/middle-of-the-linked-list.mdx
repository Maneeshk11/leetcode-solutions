# Middle of the Linked List

-----

#### Description: 

Given the ```head``` of a singly linked list, return _the middle node of the linked list._

If there are two middle nodes, return *the second middle* node.

#### Examples:

```txt
Input: head = [1,2,3,4,5]
Output: [3,4,5]
Explanation: The middle node of the list is node 3.
```

```txt
Input: head = [1,2,3,4,5,6]
Output: [4,5,6]
Explanation: Since the list has two middle nodes with values 3 and 4, we return the second one.
```

#### Constraints: 

- The number of nodes in the list is in the range ```[1, 100]```.
- ```1 <= Node.val <= 100```

#### Code: 

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        ListNode *p1 = head, *p2 = head;
        int count = 0;
        while (p2 != nullptr) {
            p2 = p2->next;
            count++;
            if (count%2 == 0) {
                p1 = p1->next;
            }
        }
        return p1;
    }
};
```

#### Explanation:

- We can solve this problem using the two-pointer technique. We will use two pointers, ```p1``` and ```p2```, and initialize them to the head of the linked list.
- We will also keep a count variable to keep track of the number of nodes we have traversed. We will increment the count variable whenever we move the ```p2``` pointer.
- We will move the ```p2``` pointer two steps ahead and the ```p1``` pointer one step ahead. This way, when the ```p2``` pointer reaches the end of the linked list, the ```p1``` pointer will be at the middle of the linked list.
- We will return the ```p1``` pointer as the middle node of the linked list.

#### Complexity Analysis:

- The time complexity for this approach is ```O(N)```, where ```N``` is the number of nodes in the linked list.